#include <iostream>
#include <fstream>
#include <string>
#include <sstream>

using namespace std;

int main(int argNum, char **argVec){
    if (argNum<10){
        cout << "Error while reading the arguments. Too few arguments introduced? \n";
        return -1;
    }
    //int option;
    //sscanf(argVec[10], "%d", &option);

    ofstream writtenFile;
    writtenFile.open("CODE_CN2D_ChiCalculator.cpp");
    if(!writtenFile.good()){
        cout << "Error while creating the code files!\n";
        return 1;
    }
    writtenFile << "// This is a programm intended to calculate the chi coefficients given a 2D input waveFunction and the adiabatic states for the sections as analytic expressions\n#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <string>\n#include <complex>\n#include \"LIB_dcomplex.h\" // Macro for using dcomplex as std::complex<double> and J as the complex 0.0+i*1.0\n#include <eigen3/Eigen/Core>\n#include <eigen3/Eigen/Sparse>\n#include <eigen3/Eigen/SparseLU>\n#include <cmath>\n#include <random>\nusing namespace std::complex_literals;\nusing namespace Eigen;\nusing namespace std;\n#define PI 3.141592653589793238463\n#define INF 1000000.0\n//USER INPUT------\n//The information for the input 2D wavefunction psi(x,y)\n\nifstream inputFileWF;\n\nint nx1="<< argVec[4]<<",nx2="<<argVec[5]<<", numIt="<<argVec[10]<<", gridPoints;\ndouble x1min="<<argVec[6]<<",x1max="<<argVec[7]<<",x2min="<<argVec[8]<<",x2max="<<argVec[9]<<",dx1,dx2, normWF, sumCorners, sumBorders, sumInterior, sumaParaChisx;\ndouble xmin="<<argVec[6]<<",xmax="<<argVec[7]<<",ymin="<<argVec[8]<<",ymax="<<argVec[9]<<";\n//The adiabatic states for sections in x and the maximum desired j to calculate\nint jmax="<< argVec[3]<<";\ncdouble integral;\nArrayXXcd Chijx_container(nx1+1, jmax+1); // Each column k contains for the energy level j=k the value of chi as a function of the section in x (the position in x)\nArrayXd sumaChisHasta(jmax+1);\ncdouble EigenstatesForSectionsInx(double y, double x, int j){"<<argVec[2] <<"}\n\n//WF EXTRACTION FROM FILE-------\nint main(){\ninputFileWF.open(\""<<argVec[1] <<"\"); //the path of the file where the WF is saved in a sequentialized matrix vector fashion\nstring line;\ncdouble arrayEl;\ngetline(inputFileWF,line);\n//istringstream ss(line);\n//ss >> nx1 >> nx2 >> nt >> dt >>x1min >> x1max >> x2min >> x2max>>m1>>m2>>hbar; //nx is the number of space division, which is one less than the number of spatial points\ngridPoints=(nx1+1)*(nx2+1);\nArrayXcd WF(gridPoints);\nArrayXd posx1(gridPoints), posx2(gridPoints), absWF(gridPoints);\nMatrixXd results(nx2+1, 3);\n//Prepare the grid in x y\ndx1=(x1max-x1min)/nx1;\ndx2=(x2max-x2min)/nx2;\nfor(int ix=0; ix<=nx1; ix++){\nfor(int iy=0; iy<=nx2; iy++){\nposx1(ix*(nx2+1)+iy) = x1min+ix*dx1;\nposx2(ix*(nx2+1)+iy) = x2min+iy*dx2;\n}\n}\n//Output files initialized\nofstream chiInfo, sumChiInfo, wfPlot;\nchiInfo.open(\"DATA_chiInfo.txt\");\nsumChiInfo.open(\"DATA_sumChiInfo.txt\");\nwfPlot.open(\"DATA_plotWFInfo.txt\");\n//BEGINING OF TIME ITERATIONS!--\nfor(int tIt=0; tIt<numIt; ++tIt){\n//Actually extract the wf\ngetline(inputFileWF,line);\nfor(int xIt=0; xIt<gridPoints; xIt++){\ngetline(inputFileWF,line);\nistringstream ss(line);\nss>>arrayEl;\nWF(xIt)=arrayEl;\n}\nabsWF=abs2(WF);\n// calculate the normWF of the WF using the 2d trapezium rule\nsumCorners = 0;\nsumBorders = 0;\nsumInterior = 0;\nsumCorners = absWF(0) + absWF(nx2) + absWF(gridPoints-1) + absWF(nx1*(nx2+1));\nfor(int ix=1; ix<nx1; ++ix){\nfor(int iy=1; iy<nx2; ++iy){\nsumInterior += absWF(ix*(nx2+1)+iy);\n}\n}\nfor(int iy=1; iy<nx2; ++iy){\nsumBorders += absWF(iy) + absWF(nx1*(nx2+1) + iy); // ix=0 row and ix=nx1 row\n}\nfor(int ix=1; ix<nx1; ++ix){\nsumBorders += absWF(ix*(nx2+1)) + absWF(ix*(nx2+1)+nx2); //iy=0 row and iy=nx2 row\n}\nnormWF=0.25*dx1*dx2*(sumCorners + 2*sumBorders +4* sumInterior);\n\n//CACLCULATE CHI_j(x,t)-----------\nsumaParaChisx=0;\nfor(int j=0; j<=jmax; ++j){\nfor(int ix=0; ix<=nx1; ++ix){ // for each section in x we integrate the WF in y restricted to this x\nintegral=0.5*(WF(ix*(nx2+1))+WF(ix*(nx2+1)+nx2));\nfor(int iy=1; iy<nx2; ++iy){\nintegral += EigenstatesForSectionsInx(x2min+iy*dx2, x1min+ix*dx1, j)*WF(ix*(nx2+1)+iy);\n}\nChijx_container(ix, j)=integral*dx2;\n}\n//we calculate the incremental sum of the moduluous of chi integrated\nsumaParaChisx+=abs2(Chijx_container.col(j)).sum();\nsumaChisHasta(j)=sumaParaChisx*dx1;\n} //OUTPUT Obtained CHI information for plots--------\n\n//chiInfo << \"x_position\";\nfor(int j=0; j<=jmax; ++j){\n//chiInfo << \" \"<< sumaChisHasta(j); //header like the sum of the chis will be printed until the given j\nsumChiInfo<<j<<\" \"<<sumaChisHasta(j)<<endl;\n}\nsumChiInfo<<endl<<endl;\n\nfor(int ix=0; ix<=nx1; ++ix){\nchiInfo << x1min+ix*dx1 << \" \";\nfor(int j=0; j<=jmax; ++j){\nchiInfo << abs(Chijx_container(ix, j)) << \" \"; //each column will have the chi values for the x given in the first column\n}\nchiInfo<<endl;\n}\nchiInfo<<endl<<endl;\n//OUTPUT WF information for plots-------------\n\nwfPlot <<\"Norm=\"<< normWF << endl;\n//output the position together with the probability\nfor(int ix=0; ix<=nx1; ix++){\nresults << posx1.block(ix*nx2+ix,0, nx2+1, 1), posx2.block(ix*nx2+ix,0, nx2+1, 1), absWF.block(ix*nx2+ix,0, nx2+1, 1);\nwfPlot <<results<<endl<< endl;\n}\nwfPlot <<endl;}\nwfPlot.close();\nchiInfo.close();\nsumChiInfo.close();\ninputFileWF.close();\nreturn 0;\n}";
    
    return 0;
}
